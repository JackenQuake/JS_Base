'use strict';

//let a = prompt("Введите целое число:"); // отрицательные числа вводит как строку
//let b = prompt("Введите целое число:");
let a = Number(prompt("Введите целое число:"));
let b = Number(prompt("Введите целое число:"));
let c;
let str;

if ((a >= 0) && (b >= 0)) {
    c = a - b;
    str = String(a) + ' - ' + String(b) + ' = ' + String(c);
}

if ((a < 0) && (b < 0)) {
    c = a * b;
    str = String(a) + ' * ' + String(b) + ' = ' + String(c);
}

if (((a >= 0) && (b < 0)) || ((a < 0) && (b >= 0))) {
    //if (a * b < 0) { // Так изящнее, но, к сожалению, не сработает, когда a < 0, b = 0, ну или наоборот.
    c = a + b;
    //c = Number(a) + Number(b); // какая то ЛАЖА!!! без привдеения типов к числовому- считает отрицательное число как строку...
    str = String(a) + ' + ' + String(b) + ' = ' + String(c);
}

alert(str);

// Я наткнулся на следующий "тонкий" момент в JS:
// если через prompt - вводить отрицательное число, то оно воспринимается не как число, а как строка... В задании номер 3 (подзадаче с умножением) однако проблем не возникает, т.к. операция умножения не определена для строк - и неявное приведение типов срабатывает - интерпретатор пытается привести их к типу, где определено умножение, т.е. к числовому... А вот на операции сложения, которое определено для строк как конкатенация - интерпретатор не приводит типы и по умолчанию - происходит конкатенация строк.